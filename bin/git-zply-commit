#!/bin/bash
# Commit all patches to patch repo
CMD='git zply-commit'
VERSION=0.1

function version() {
    echo $VERSION
    exit 0
}

function die() {
    >&2 echo "[$CMD error]: $@"
    exit 1
}

function realpath {
    echo $(cd $(dirname $1); pwd)/$(basename $1);
}

function check_patch_repo() {
    if [[ ! -e $1 ]]; then
        die "Patch repo directory not found"
    elif [[ ! -e $1/.git ]]; then
        die "Patch repo is not a git repo (did you git init it?)"
    fi
}

function usage() {
    >&2 echo $@ "usage: git zply-commit [-h] [-v] [-b based-on] <patch-repo-patch>"
    exit 1
}

while getopts 'b:hv' opt; do
    case $opt in
        b) BASED_ON=$OPTARG;;
        h) usage;;
        v) version;;
        *) usage;;
    esac
done

shift $(($OPTIND - 1))

if [[ -z $1 ]]; then
    usage
fi

PATCH_REPO_PATH=`realpath $1`
check_patch_repo $PATCH_REPO_PATH

pushd $PATCH_REPO_PATH > /dev/null
cat > .tmp-commit-msg <<-EOF
Saving patches...
EOF

# Add based-on annotation
if [[ -n $BASED_ON ]]; then
    echo >> .tmp-commit-msg
    echo "Based-On: $BASED_ON" >> .tmp-commit-msg
fi

# -t would abort the commit if the message was not edited; we don't want to
# require that in all cases, so using -eF instead
git commit -qeF .tmp-commit-msg
rm .tmp-commit-msg
echo "Commited patches"
popd > /dev/null
